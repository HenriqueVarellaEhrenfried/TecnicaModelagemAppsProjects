/*
 * generated by Xtext 2.12.0
 */
package org.xtext.trabalho.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.trabalho.mAL.AnyType;
import org.xtext.trabalho.mAL.Binding;
import org.xtext.trabalho.mAL.Definition;
import org.xtext.trabalho.mAL.Expr;
import org.xtext.trabalho.mAL.Factor;
import org.xtext.trabalho.mAL.Fcncall;
import org.xtext.trabalho.mAL.Header;
import org.xtext.trabalho.mAL.Helpinfo;
import org.xtext.trabalho.mAL.IncludeStmt;
import org.xtext.trabalho.mAL.MALPackage;
import org.xtext.trabalho.mAL.ModuleName;
import org.xtext.trabalho.mAL.ModuleStmt;
import org.xtext.trabalho.mAL.Name;
import org.xtext.trabalho.mAL.Params;
import org.xtext.trabalho.mAL.Program;
import org.xtext.trabalho.mAL.ScalarType;
import org.xtext.trabalho.mAL.Stmt;
import org.xtext.trabalho.mAL.Variable;
import org.xtext.trabalho.mAL.Varlist;
import org.xtext.trabalho.services.MALGrammarAccess;

@SuppressWarnings("all")
public class MALSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MALGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MALPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MALPackage.ANY_TYPE:
				sequence_AnyType(context, (AnyType) semanticObject); 
				return; 
			case MALPackage.BINDING:
				sequence_Binding(context, (Binding) semanticObject); 
				return; 
			case MALPackage.DEFINITION:
				if (rule == grammarAccess.getDefinitionRule()) {
					sequence_Definition(context, (Definition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_Definition_Statement(context, (Definition) semanticObject); 
					return; 
				}
				else break;
			case MALPackage.EXPR:
				sequence_Expr(context, (Expr) semanticObject); 
				return; 
			case MALPackage.FACTOR:
				if (rule == grammarAccess.getArgsRule()) {
					sequence_Args_Factor(context, (Factor) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFactorRule()) {
					sequence_Factor(context, (Factor) semanticObject); 
					return; 
				}
				else break;
			case MALPackage.FCNCALL:
				sequence_Fcncall(context, (Fcncall) semanticObject); 
				return; 
			case MALPackage.HEADER:
				sequence_Header(context, (Header) semanticObject); 
				return; 
			case MALPackage.HELPINFO:
				sequence_Helpinfo(context, (Helpinfo) semanticObject); 
				return; 
			case MALPackage.INCLUDE_STMT:
				sequence_IncludeStmt(context, (IncludeStmt) semanticObject); 
				return; 
			case MALPackage.MODULE_NAME:
				if (rule == grammarAccess.getModuleNameRule()) {
					sequence_ModuleName(context, (ModuleName) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNameRule()) {
					sequence_ModuleName_Name(context, (ModuleName) semanticObject); 
					return; 
				}
				else break;
			case MALPackage.MODULE_STMT:
				if (rule == grammarAccess.getModuleStmtRule()) {
					sequence_ModuleStmt(context, (ModuleStmt) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_ModuleStmt_Statement(context, (ModuleStmt) semanticObject); 
					return; 
				}
				else break;
			case MALPackage.NAME:
				sequence_Name(context, (Name) semanticObject); 
				return; 
			case MALPackage.PARAMS:
				sequence_Params(context, (Params) semanticObject); 
				return; 
			case MALPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case MALPackage.SCALAR_TYPE:
				sequence_ScalarType(context, (ScalarType) semanticObject); 
				return; 
			case MALPackage.STMT:
				sequence_Stmt(context, (Stmt) semanticObject); 
				return; 
			case MALPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case MALPackage.VARLIST:
				sequence_Varlist(context, (Varlist) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Result returns AnyType
	 *     TypeName returns AnyType
	 *     ColumnType returns AnyType
	 *     ColElmType returns AnyType
	 *     AnyType returns AnyType
	 *
	 * Constraint:
	 *     (type='any' digit=OID?)
	 */
	protected void sequence_AnyType(ISerializationContext context, AnyType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Args returns Factor
	 *
	 * Constraint:
	 *     factor1+=Factor*
	 */
	protected void sequence_Args_Factor(ISerializationContext context, Factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Binding returns Binding
	 *
	 * Constraint:
	 *     (identifier=WRD type=TypeName)
	 */
	protected void sequence_Binding(ISerializationContext context, Binding semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MALPackage.Literals.BINDING__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MALPackage.Literals.BINDING__IDENTIFIER));
			if (transientValues.isValueTransient(semanticObject, MALPackage.Literals.BINDING__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MALPackage.Literals.BINDING__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBindingAccess().getIdentifierWRDTerminalRuleCall_0_0(), semanticObject.getIdentifier());
		feeder.accept(grammarAccess.getBindingAccess().getTypeTypeNameParserRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns Definition
	 *
	 * Constraint:
	 *     (
	 *         (header=Header identifier=WRD) | 
	 *         (header=Header identifier=WRD) | 
	 *         (header=Header statements+=Statement* function_name=Name) | 
	 *         (header=Header statements+=Statement* factory_name=Name)
	 *     )
	 */
	protected void sequence_Definition(ISerializationContext context, Definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Definition
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (header=Header identifier=WRD) | 
	 *             (header=Header identifier=WRD) | 
	 *             (header=Header statements+=Statement* function_name=Name) | 
	 *             (header=Header statements+=Statement* factory_name=Name)
	 *         ) 
	 *         help?=Helpinfo?
	 *     )
	 */
	protected void sequence_Definition_Statement(ISerializationContext context, Definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns Expr
	 *
	 * Constraint:
	 *     ((left_factor=Factor operator=Operator)? right_factor=Factor)
	 */
	protected void sequence_Expr(ISerializationContext context, Expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Factor returns Factor
	 *
	 * Constraint:
	 *     {Factor}
	 */
	protected void sequence_Factor(ISerializationContext context, Factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns Fcncall
	 *     Fcncall returns Fcncall
	 *
	 * Constraint:
	 *     (module=ModuleName function_name=Name args?=Args?)
	 */
	protected void sequence_Fcncall(ISerializationContext context, Fcncall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Header returns Header
	 *
	 * Constraint:
	 *     (header_name=Name params=Params return_type=Result)
	 */
	protected void sequence_Header(ISerializationContext context, Header semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MALPackage.Literals.HEADER__HEADER_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MALPackage.Literals.HEADER__HEADER_NAME));
			if (transientValues.isValueTransient(semanticObject, MALPackage.Literals.HEADER__PARAMS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MALPackage.Literals.HEADER__PARAMS));
			if (transientValues.isValueTransient(semanticObject, MALPackage.Literals.HEADER__RETURN_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MALPackage.Literals.HEADER__RETURN_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHeaderAccess().getHeader_nameNameParserRuleCall_0_0(), semanticObject.getHeader_name());
		feeder.accept(grammarAccess.getHeaderAccess().getParamsParamsParserRuleCall_2_0(), semanticObject.getParams());
		feeder.accept(grammarAccess.getHeaderAccess().getReturn_typeResultParserRuleCall_4_0(), semanticObject.getReturn_type());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Helpinfo returns Helpinfo
	 *
	 * Constraint:
	 *     string_literal=STRING
	 */
	protected void sequence_Helpinfo(ISerializationContext context, Helpinfo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MALPackage.Literals.HELPINFO__STRING_LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MALPackage.Literals.HELPINFO__STRING_LITERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHelpinfoAccess().getString_literalSTRINGTerminalRuleCall_1_0(), semanticObject.getString_literal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IncludeStmt
	 *     IncludeStmt returns IncludeStmt
	 *
	 * Constraint:
	 *     (identifier=WRD | string_literal=STRING)
	 */
	protected void sequence_IncludeStmt(ISerializationContext context, IncludeStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleName returns ModuleName
	 *
	 * Constraint:
	 *     identifier=WRD
	 */
	protected void sequence_ModuleName(ISerializationContext context, ModuleName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MALPackage.Literals.MODULE_NAME__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MALPackage.Literals.MODULE_NAME__IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModuleNameAccess().getIdentifierWRDTerminalRuleCall_0(), semanticObject.getIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Name returns ModuleName
	 *
	 * Constraint:
	 *     (identifier=WRD id=WRD)
	 */
	protected void sequence_ModuleName_Name(ISerializationContext context, ModuleName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MALPackage.Literals.MODULE_NAME__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MALPackage.Literals.MODULE_NAME__IDENTIFIER));
			if (transientValues.isValueTransient(semanticObject, MALPackage.Literals.NAME__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MALPackage.Literals.NAME__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModuleNameAccess().getIdentifierWRDTerminalRuleCall_0(), semanticObject.getIdentifier());
		feeder.accept(grammarAccess.getNameAccess().getIdWRDTerminalRuleCall_1_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModuleStmt returns ModuleStmt
	 *
	 * Constraint:
	 *     (ident=WRD | (ident=WRD second_ident?=WRD?))
	 */
	protected void sequence_ModuleStmt(ISerializationContext context, ModuleStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ModuleStmt
	 *
	 * Constraint:
	 *     ((ident=WRD | (ident=WRD second_ident?=WRD?)) help?=Helpinfo?)
	 */
	protected void sequence_ModuleStmt_Statement(ISerializationContext context, ModuleStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Name returns Name
	 *
	 * Constraint:
	 *     id=WRD
	 */
	protected void sequence_Name(ISerializationContext context, Name semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MALPackage.Literals.NAME__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MALPackage.Literals.NAME__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNameAccess().getIdWRDTerminalRuleCall_1_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Result returns Params
	 *     Params returns Params
	 *
	 * Constraint:
	 *     (bind+=Binding bind+=Binding*)
	 */
	protected void sequence_Params(ISerializationContext context, Params semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     elements+=Statement+
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Result returns ScalarType
	 *     TypeName returns ScalarType
	 *     ScalarType returns ScalarType
	 *     ColumnType returns ScalarType
	 *     ColElmType returns ScalarType
	 *
	 * Constraint:
	 *     identifier=WRD
	 */
	protected void sequence_ScalarType(ISerializationContext context, ScalarType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MALPackage.Literals.SCALAR_TYPE__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MALPackage.Literals.SCALAR_TYPE__IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScalarTypeAccess().getIdentifierWRDTerminalRuleCall_1_0(), semanticObject.getIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Stmt
	 *     Stmt returns Stmt
	 *
	 * Constraint:
	 *     (flow?=Flow? list_of_variables=Varlist exp=Expr?)
	 */
	protected void sequence_Stmt(ISerializationContext context, Stmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     identifier=WRD
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MALPackage.Literals.VARIABLE__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MALPackage.Literals.VARIABLE__IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getIdentifierWRDTerminalRuleCall_0(), semanticObject.getIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Varlist returns Varlist
	 *
	 * Constraint:
	 *     (variables+=Variable | (variables+=Variable variables+=Variable*))
	 */
	protected void sequence_Varlist(ISerializationContext context, Varlist semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
