/*
 * generated by Xtext 2.12.0
 */
package org.xtext.trabalho.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.trabalho.mAL.AnyType;
import org.xtext.trabalho.mAL.Args;
import org.xtext.trabalho.mAL.Binding;
import org.xtext.trabalho.mAL.ColElmType;
import org.xtext.trabalho.mAL.Expr;
import org.xtext.trabalho.mAL.Factor;
import org.xtext.trabalho.mAL.Helpinfo;
import org.xtext.trabalho.mAL.IncludeStmt;
import org.xtext.trabalho.mAL.MALPackage;
import org.xtext.trabalho.mAL.ModuleName;
import org.xtext.trabalho.mAL.ModuleStmt;
import org.xtext.trabalho.mAL.Name;
import org.xtext.trabalho.mAL.Program;
import org.xtext.trabalho.mAL.ScalarType;
import org.xtext.trabalho.mAL.TypeName;
import org.xtext.trabalho.mAL.Variable;
import org.xtext.trabalho.services.MALGrammarAccess;

@SuppressWarnings("all")
public class MALSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MALGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MALPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MALPackage.ANY_TYPE:
				sequence_AnyType(context, (AnyType) semanticObject); 
				return; 
			case MALPackage.ARGS:
				sequence_Args(context, (Args) semanticObject); 
				return; 
			case MALPackage.BINDING:
				if (rule == grammarAccess.getBindingRule()) {
					sequence_Binding(context, (Binding) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getResultRule()
						|| rule == grammarAccess.getParamsRule()) {
					sequence_Binding_Params(context, (Binding) semanticObject); 
					return; 
				}
				else break;
			case MALPackage.COL_ELM_TYPE:
				sequence_ColElmType(context, (ColElmType) semanticObject); 
				return; 
			case MALPackage.EXPR:
				sequence_Expr(context, (Expr) semanticObject); 
				return; 
			case MALPackage.FACTOR:
				if (rule == grammarAccess.getArgsRule()) {
					sequence_Args_Factor(context, (Factor) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExprRule()) {
					sequence_Expr_Factor(context, (Factor) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFactorRule()) {
					sequence_Factor(context, (Factor) semanticObject); 
					return; 
				}
				else break;
			case MALPackage.HELPINFO:
				sequence_Helpinfo(context, (Helpinfo) semanticObject); 
				return; 
			case MALPackage.INCLUDE_STMT:
				sequence_IncludeStmt(context, (IncludeStmt) semanticObject); 
				return; 
			case MALPackage.MODULE_NAME:
				if (rule == grammarAccess.getExprRule()
						|| rule == grammarAccess.getFcncallRule()) {
					sequence_Fcncall_ModuleName(context, (ModuleName) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getModuleNameRule()) {
					sequence_ModuleName(context, (ModuleName) semanticObject); 
					return; 
				}
				else break;
			case MALPackage.MODULE_STMT:
				if (rule == grammarAccess.getModuleStmtRule()) {
					sequence_ModuleStmt(context, (ModuleStmt) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_ModuleStmt_Statement(context, (ModuleStmt) semanticObject); 
					return; 
				}
				else break;
			case MALPackage.NAME:
				if (rule == grammarAccess.getDefinitionRule()) {
					sequence_Definition_Header_Name(context, (Name) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_Definition_Header_Name_Statement(context, (Name) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getHeaderRule()) {
					sequence_Header_Name(context, (Name) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNameRule()) {
					sequence_Name(context, (Name) semanticObject); 
					return; 
				}
				else break;
			case MALPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case MALPackage.SCALAR_TYPE:
				sequence_ScalarType(context, (ScalarType) semanticObject); 
				return; 
			case MALPackage.TYPE_NAME:
				sequence_TypeName(context, (TypeName) semanticObject); 
				return; 
			case MALPackage.VARIABLE:
				if (rule == grammarAccess.getStatementRule()
						|| rule == grammarAccess.getStmtRule()) {
					sequence_Stmt_Variable_Varlist(context, (Variable) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableRule()) {
					sequence_Variable(context, (Variable) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVarlistRule()) {
					sequence_Variable_Varlist(context, (Variable) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AnyType returns AnyType
	 *
	 * Constraint:
	 *     digit=ID
	 */
	protected void sequence_AnyType(ISerializationContext context, AnyType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MALPackage.Literals.ANY_TYPE__DIGIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MALPackage.Literals.ANY_TYPE__DIGIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnyTypeAccess().getDigitIDTerminalRuleCall_1_1_0(), semanticObject.getDigit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Args returns Args
	 *
	 * Constraint:
	 *     factor=Factor+
	 */
	protected void sequence_Args(ISerializationContext context, Args semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Args returns Factor
	 *
	 * Constraint:
	 *     ((literal_constant=ID | var=ID) factor=Factor*)
	 */
	protected void sequence_Args_Factor(ISerializationContext context, Factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Binding returns Binding
	 *
	 * Constraint:
	 *     (identifier=ID tn=TypeName)
	 */
	protected void sequence_Binding(ISerializationContext context, Binding semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MALPackage.Literals.BINDING__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MALPackage.Literals.BINDING__IDENTIFIER));
			if (transientValues.isValueTransient(semanticObject, MALPackage.Literals.BINDING__TN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MALPackage.Literals.BINDING__TN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBindingAccess().getIdentifierIDTerminalRuleCall_0_0(), semanticObject.getIdentifier());
		feeder.accept(grammarAccess.getBindingAccess().getTnTypeNameParserRuleCall_1_0(), semanticObject.getTn());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Result returns Binding
	 *     Params returns Binding
	 *
	 * Constraint:
	 *     (identifier=ID tn=TypeName bind=Binding*)
	 */
	protected void sequence_Binding_Params(ISerializationContext context, Binding semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Result returns ColElmType
	 *     TypeName returns ColElmType
	 *     ColumnType returns ColElmType
	 *     ColElmType returns ColElmType
	 *
	 * Constraint:
	 *     at=AnyType
	 */
	protected void sequence_ColElmType(ISerializationContext context, ColElmType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MALPackage.Literals.TYPE_NAME__AT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MALPackage.Literals.TYPE_NAME__AT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColElmTypeAccess().getAtAnyTypeParserRuleCall_1_0(), semanticObject.getAt());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns Name
	 *
	 * Constraint:
	 *     (
	 *         ((mn+=ModuleName* id=ID) | id=ID) 
	 *         param=Params 
	 *         result=Result 
	 *         (identifier=ID | identifier=ID | (stm=Statement* name=Name) | (stm=Statement* name=Name))
	 *     )
	 */
	protected void sequence_Definition_Header_Name(ISerializationContext context, Name semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Name
	 *
	 * Constraint:
	 *     (
	 *         ((mn+=ModuleName* id=ID) | id=ID) 
	 *         param=Params 
	 *         result=Result 
	 *         (identifier=ID | identifier=ID | (stm=Statement* name=Name) | (stm=Statement* name=Name)) 
	 *         help=Helpinfo?
	 *     )
	 */
	protected void sequence_Definition_Header_Name_Statement(ISerializationContext context, Name semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns Expr
	 *
	 * Constraint:
	 *     (operator=ID? factor=Factor)
	 */
	protected void sequence_Expr(ISerializationContext context, Expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns Factor
	 *
	 * Constraint:
	 *     ((literal_constant=ID | var=ID) operator=ID factor=Factor)
	 */
	protected void sequence_Expr_Factor(ISerializationContext context, Factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Factor returns Factor
	 *
	 * Constraint:
	 *     (literal_constant=ID | var=ID)
	 */
	protected void sequence_Factor(ISerializationContext context, Factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns ModuleName
	 *     Fcncall returns ModuleName
	 *
	 * Constraint:
	 *     (identifier=ID name=Name args=Args?)
	 */
	protected void sequence_Fcncall_ModuleName(ISerializationContext context, ModuleName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Header returns Name
	 *
	 * Constraint:
	 *     (((mn+=ModuleName* id=ID) | id=ID) param=Params result=Result)
	 */
	protected void sequence_Header_Name(ISerializationContext context, Name semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Helpinfo returns Helpinfo
	 *
	 * Constraint:
	 *     string_literal=ID
	 */
	protected void sequence_Helpinfo(ISerializationContext context, Helpinfo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MALPackage.Literals.HELPINFO__STRING_LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MALPackage.Literals.HELPINFO__STRING_LITERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHelpinfoAccess().getString_literalIDTerminalRuleCall_1_0(), semanticObject.getString_literal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IncludeStmt
	 *     IncludeStmt returns IncludeStmt
	 *
	 * Constraint:
	 *     (identifier=ID | string_literal=ID)
	 */
	protected void sequence_IncludeStmt(ISerializationContext context, IncludeStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleName returns ModuleName
	 *
	 * Constraint:
	 *     identifier=ID
	 */
	protected void sequence_ModuleName(ISerializationContext context, ModuleName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MALPackage.Literals.MODULE_NAME__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MALPackage.Literals.MODULE_NAME__IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModuleNameAccess().getIdentifierIDTerminalRuleCall_0(), semanticObject.getIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModuleStmt returns ModuleStmt
	 *
	 * Constraint:
	 *     (ident=ID | (ident=ID ident=ID?))
	 */
	protected void sequence_ModuleStmt(ISerializationContext context, ModuleStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ModuleStmt
	 *
	 * Constraint:
	 *     ((ident=ID | (ident=ID ident=ID?)) help=Helpinfo?)
	 */
	protected void sequence_ModuleStmt_Statement(ISerializationContext context, ModuleStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Name returns Name
	 *
	 * Constraint:
	 *     ((mn+=ModuleName* id=ID) | id=ID)
	 */
	protected void sequence_Name(ISerializationContext context, Name semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     elements+=Statement+
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Result returns ScalarType
	 *     TypeName returns ScalarType
	 *     ScalarType returns ScalarType
	 *     ColumnType returns ScalarType
	 *     ColElmType returns ScalarType
	 *
	 * Constraint:
	 *     identifier=ID
	 */
	protected void sequence_ScalarType(ISerializationContext context, ScalarType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MALPackage.Literals.SCALAR_TYPE__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MALPackage.Literals.SCALAR_TYPE__IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScalarTypeAccess().getIdentifierIDTerminalRuleCall_1_0(), semanticObject.getIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Variable
	 *     Stmt returns Variable
	 *
	 * Constraint:
	 *     (identifier=ID var=Variable* exp=Expr)
	 */
	protected void sequence_Stmt_Variable_Varlist(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Result returns TypeName
	 *     TypeName returns TypeName
	 *
	 * Constraint:
	 *     at=AnyType
	 */
	protected void sequence_TypeName(ISerializationContext context, TypeName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MALPackage.Literals.TYPE_NAME__AT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MALPackage.Literals.TYPE_NAME__AT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeNameAccess().getAtAnyTypeParserRuleCall_2_1_0(), semanticObject.getAt());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     identifier=ID
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MALPackage.Literals.VARIABLE__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MALPackage.Literals.VARIABLE__IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getIdentifierIDTerminalRuleCall_0(), semanticObject.getIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Varlist returns Variable
	 *
	 * Constraint:
	 *     (identifier=ID var=Variable*)
	 */
	protected void sequence_Variable_Varlist(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
