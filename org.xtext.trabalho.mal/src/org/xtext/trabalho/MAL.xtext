grammar org.xtext.trabalho.MAL with org.eclipse.xtext.common.Terminals

generate mAL "http://www.xtext.org/trabalho/MAL"

Program:
	(elements+=Statement ';')*
;

Statement:
	ModuleStmt (help?=Helpinfo)? | Definition (help?=Helpinfo)? | IncludeStmt | Stmt
;

ModuleStmt:
	'MODULE' ident=ID | 'ATOM' ident=ID (':' second_ident?=ID)?
;

IncludeStmt:
	'INCLUDE' identifier=ID | 'INCLUDE' string_literal=STRING
;

Definition:
	('UNSAFE')? 'COMMAND' header=Header 'ADDRESS' identifier=ID | //Nosso Comando possuí um header e um identificador
	('UNSAFE')? 'PATTERN' header=Header 'ADDRESS' identifier=ID | //Nosso Pattern possuí um header e um identificador
	('INLINE' | 'UNSAFE' )? 'FUNCTION' header=Header (statements+=Statement)* 'END' function_name=Name | // Nossa função possuí um header, os seus statements e o nome da função
	'FACTORY' header=Header (statements+=Statement)* 'END' factory_name=Name // Nossa factory possuí um header, os seus statements e o nome da função
;

Helpinfo:
	'COMMENT' string_literal=STRING
;

Header:
	header_name=Name '(' params=Params ')' return_type=Result // Nosso Header possuí um name que contém o seu Nome, params que é uma lista de parametros e um tipo de retorno.
;

Name:
	(mn+=[ModuleName] '.')* id=ID // TODO: Descobrir o que é ModuleName
;


Result:
	TypeName | '(' Params ')'
;

Params: 
	bind+=Binding (',' bind+=Binding)*
;

Binding:
	identifier=ID type=TypeName
;

TypeName:
	ScalarType | ColumnType | ':' AnyType // TODO: any e digit são ID???? 
;

ScalarType:
	':' identifier=ID
;

ColumnType:
	':' 'BAT' '[' ':' ColElmType ']'
;

ColElmType:
	ScalarType | AnyType // TODO: Descobrir o que é AnyType
;

AnyType:
	type='any' ('_' digit=ID)?
;

Stmt:
	(flow?=Flow)? list_of_variables=Varlist (':=' exp=Expr)
;

Flow:
	'RETURN'  | 'BARRIER' | 'CATCH' | 'LEAVE' | 'REDO' | 'RAISE'
;

Varlist:
	variables+=Variable | '(' variables+=Variable (',' variables+=Variable)* ')'
;

Variable:
	identifier=ID
;

Expr:
	Fcncall | (left_factor=Factor operator=Operator)? right_factor=Factor // TODO: operator é ID????
;

Operator:
	'+' | '-' | '*' | '/'
;

Factor:
	{Factor}Literal_constant | {Factor}'NIL' | Variable // {Factor} foi colocado porque quando o retorno de uma regra é uma string tipo 'NIL' o objeto não é criado, então ele garante a criação 
;

Fcncall:
	module=ModuleName '.' function_name=Name '(' (args?=Args)? ')' // TODO: Descobrir o que é ModuleName
;

Args:
	Factor (',' factor1+=Factor)*
;

ModuleName:
	identifier=ID
;

Literal_constant:
	BIT | Bte | CHR | WRD | INT | OID | FLT | STR //| Sht | LNG | DBL
;

terminal BIT:
	'0' | '1'
;
Bte:
	BIT BIT BIT BIT BIT BIT BIT BIT
;
terminal CHR:
	('a'..'z'|'A'..'Z'|'_'|'0'..'9')
;
terminal WRD:
	('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
;
terminal OID:
	('1'..'9') ('0'..'9')*
;
FLT:
	INT'.'INT
;
STR:
	STRING
;