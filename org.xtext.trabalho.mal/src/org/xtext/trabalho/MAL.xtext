grammar org.xtext.trabalho.MAL with org.eclipse.xtext.common.Terminals

generate mAL "http://www.xtext.org/trabalho/MAL"

Program:
	(elements+=Statement ';')*
;

Statement:
	ModuleStmt (help?=Helpinfo)? | Definition (help?=Helpinfo)? | IncludeStmt | Stmt
;

ModuleStmt:
	('MODULE' | 'module') ident=WRD | ('ATOM' | 'atom') ident=WRD (':' second_ident?=WRD)?
;

IncludeStmt:
	('INCLUDE' | 'include') identifier=WRD | ('INCLUDE' | 'include') string_literal=STRING
;

// In the examples the unsafe part is in a different location, not in the beginning
Definition:
	(('UNSAFE' | 'unsafe'))? ('COMMAND' | 'command') header=Header ('ADDRESS' | 'address') identifier=WRD |
	(('UNSAFE' | 'unsafe'))? ('PATTERN' | 'pattern') header=Header ('ADDRESS' | 'address') identifier=WRD |
	(('INLINE' | 'inline') | ('UNSAFE' | 'unsafe'))? ('FUNCTION' | 'function') header=Header (statements+=Statement)* ('END' | 'end') function_name=Name |
	('FACTORY' | 'factory') header=Header (statements+=Statement)* ('END' | 'end') factory_name=Name
;

Helpinfo:
	('COMMENT' | 'comment') string_literal=STRING
;

Header:
	header_name=Name '(' params=Params ')' return_type=Result
;

Name:
	(ModuleName '.')? id=WRD
;


Result:
	TypeName | '(' Params ')'
;

Params: 
	bind+=Binding (',' bind+=Binding)*
;

Binding:
	identifier=WRD type=TypeName
;

TypeName:
	ScalarType | ColumnType | AnyType 
;

ScalarType:
	':' identifier=WRD
;

// In the examples using ColumnType there is only one colon when defining the ColElmType, but using the provided grammar there will always be two colons 
ColumnType:
	':' ('BAT' | 'bat') '[' ':' ColElmType ']'
;

ColElmType:
	ScalarType | AnyType
;

// AnyType was not defined in the original rules
AnyType:
	':' type='any' ('_' digit=OID)?
;

// The Stmt rule enforces that every function call needs to be assigned to a variable or a list of variables
Stmt:
	(flow?=Flow)? list_of_variables=Varlist (':=' exp=Expr)?
;

Flow:
	('RETURN' | 'return' ) | ('BARRIER' | 'barrier') | ('CATCH' | 'catch') | ('LEAVE' | 'leave') | ('REDO' | 'redo') | ('RAISE' | 'raise')
;

Varlist:
	variables+=Variable | '(' variables+=Variable (',' variables+=Variable)* ')'
;

// Identifier was not defined by the grammar, so we decided to use the WRD rule as an identifier. The ID rule provided by XTEXT was buggy, so we decided to create our own.
Variable:
	identifier=WRD
;

Expr:
	Fcncall | (left_factor=Factor operator=Operator)? right_factor=Factor
;

// Operator was not defined in the original rules
Operator:
	'+' | '-' | '*' | '/' | '>' | '<' | '=' | '<=' | '>=' | '!=' | '&&' | '||' | '!'
;

Factor:
	{Factor}Literal_constant | {Factor}('NIL'|'nil')  // {Factor} is here because when a rule returns a string, like 'NIL', the object is not created, so {Factor} guarantees the object creation 
;

Fcncall:
	module=ModuleName '.' function_name=Name '(' (args?=Args)? ')'
;

Args:
	Factor (',' factor1+=Factor)*
;

// ModuleName was not defined in the original rules
ModuleName:
	identifier=WRD
;

// Literal_constant was not defined in the original rules, the same for everyone of its "children"
Literal_constant:
	BIT | Bte | CHR | WRD | INT | OID | FLT | STR
;

terminal BIT:
	'0' | '1'
;
Bte:
	BIT BIT BIT BIT BIT BIT BIT BIT
;
terminal CHR:
	"'"('a'..'z'|'A'..'Z'|'_'|'0'..'9')"'"
;
terminal WRD:
	('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
;
terminal OID:
	('1'..'9') ('0'..'9')*
;
FLT:
	INT'.'INT
;
STR:
	STRING
;