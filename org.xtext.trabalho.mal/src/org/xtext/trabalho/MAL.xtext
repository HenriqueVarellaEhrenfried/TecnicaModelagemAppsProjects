grammar org.xtext.trabalho.MAL with org.eclipse.xtext.common.Terminals

generate mAL "http://www.xtext.org/trabalho/MAL"

Program:
	(elements+=Statement ';')*
;

Statement:
	ModuleStmt (help?=Helpinfo)? | Definition (help?=Helpinfo)? | IncludeStmt | Stmt
;

ModuleStmt:
	('MODULE' | 'module') ident=ID | ('ATOM' | 'atom') ident=ID (':' second_ident?=ID)?
;

IncludeStmt:
	('INCLUDE' | 'include') identifier=ID | ('INCLUDE' | 'include') string_literal=STRING
;

Definition:
	(('UNSAFE' | 'unsafe'))? ('COMMAND' | 'command') header=Header ('ADDRESS' | 'address') identifier=ID | //Nosso Comando possuí um header e um identificador
	(('UNSAFE' | 'unsafe'))? ('PATTERN' | 'pattern') header=Header ('ADDRESS' | 'address') identifier=ID | //Nosso Pattern possuí um header e um identificador
	(('INLINE' | 'inline') | ('UNSAFE' | 'unsafe'))? ('FUNCTION' | 'function') header=Header (statements+=Statement)* ('END' | 'end') function_name=Name | // Nossa função possuí um header, os seus statements e o nome da função
	('FACTORY' | 'factory') header=Header (statements+=Statement)* ('END' | 'end') factory_name=Name // Nossa factory possuí um header, os seus statements e o nome da função
;

Helpinfo:
	('COMMENT' | 'comment') string_literal=STRING
;

Header:
	header_name=Name '(' params=Params ')' return_type=Result // Nosso Header possuí um name que contém o seu Nome, params que é uma lista de parametros e um tipo de retorno.
;

Name:
	(mn+=[ModuleName] '.')* id=ID // TODO: Descobrir o que é ModuleName
;


Result:
	TypeName | '(' Params ')'
;

Params: 
	bind+=Binding (',' bind+=Binding)*
;

Binding:
	identifier=ID type=TypeName
;

TypeName:
	ScalarType | ColumnType | ':' AnyType // TODO: any e digit são ID???? 
;

ScalarType:
	':' identifier=ID
;

ColumnType:
	':' ('BAT' | 'bat') '[' ':' ColElmType ']'
;

ColElmType:
	ScalarType | AnyType // TODO: Descobrir o que é AnyType
;

AnyType:
	type='any' ('_' digit=ID)?
;

Stmt:
	(flow?=Flow)? list_of_variables=Varlist (':=' exp=Expr)
;

Flow:
	('RETURN' | 'return' ) | ('BARRIER' | 'barrier') | ('CATCH' | 'catch') | ('LEAVE' | 'leave') | ('REDO' | 'redo') | ('RAISE' | 'raise')
;

Varlist:
	variables+=Variable | '(' variables+=Variable (',' variables+=Variable)* ')'
;

Variable:
	identifier=ID
;

Expr:
	Fcncall | (left_factor=Factor operator=Operator)? right_factor=Factor // TODO: operator é ID????
;

Operator:
	'+' | '-' | '*' | '/'
;

Factor:
	{Factor}Literal_constant | {Factor}'NIL' | Variable // {Factor} foi colocado porque quando o retorno de uma regra é uma string tipo 'NIL' o objeto não é criado, então ele garante a criação 
;

Fcncall:
	module=ModuleName '.' function_name=Name '(' (args?=Args)? ')' // TODO: Descobrir o que é ModuleName
;

Args:
	Factor (',' factor1+=Factor)*
;

ModuleName:
	identifier=ID
;

Literal_constant:
	BIT | Bte | CHR | WRD | INT | OID | FLT | STR   //| Sht | LNG | DBL
;

terminal BIT:
	'0' | '1'
;
Bte:
	BIT BIT BIT BIT BIT BIT BIT BIT
;
terminal CHR:
	('a'..'z'|'A'..'Z'|'_'|'0'..'9')
;
terminal WRD:
	('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
;
terminal OID:
	('1'..'9') ('0'..'9')*
;
FLT:
	INT'.'INT
;
STR:
	STRING
;